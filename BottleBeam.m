classdef BottleBeam
    % BottleBeam: Models an optical bottle generated by superposing two Bessel beams.
    % Reference: J. Arlt and M. J. Padgett, "Generation of a beam with a dark focus 
    % surrounded by regions of higher intensity: The optical bottle beam," 
    % Opt. Lett. 25, 191-193 (2000).

    properties
        wavelength      % Wavelength in meters
        beta_r          % Radial wavenumber (determines the radius of the bottle)
        delta_z         % Longitudinal separation parameter (determines length of bottle)
        w0              % Gaussian apodization waist
        
        % Derived
        k               % Total wavenumber
        beta1           % Radial k of first Bessel beam
        beta2           % Radial k of second Bessel beam
        z_max           % Geometric range (limited by Gaussian envelope)
    end
    
    methods
        function obj = BottleBeam(wavelength, beta_center, delta_beta, w0)
            % Constructor
            % beta_center: Average radial wavenumber (controls bottle width)
            % delta_beta:  Difference in radial wavenumbers (controls bottle length)
            % w0:          Gaussian aperture size
            
            obj.wavelength = wavelength;
            obj.w0 = w0;
            obj.k = 2 * pi / wavelength;
            
            % We construct the bottle by superposing two Bessel beams 
            % with slightly different cone angles (betas).
            obj.beta1 = beta_center - delta_beta/2;
            obj.beta2 = beta_center + delta_beta/2;
            
            % Store for reference
            obj.beta_r = beta_center;
            
            % Approximate length of the bottle L ~ 2*pi / (kz1 - kz2)
            kz1 = sqrt(obj.k^2 - obj.beta1^2);
            kz2 = sqrt(obj.k^2 - obj.beta2^2);
            obj.delta_z = 2 * pi / abs(kz1 - kz2);
            
            % Geometric diffraction-free limit (approx average)
            obj.z_max = obj.k * w0 / beta_center;
        end
        
        function field = generate_beam_field(obj, r, phi, z, varargin)
            p_parser = inputParser;
            addRequired(p_parser, 'r');
            addRequired(p_parser, 'phi');
            addRequired(p_parser, 'z');
            addParameter(p_parser, 'P_tx_watts', 1.0);
            addParameter(p_parser, 'tx_aperture_radius', []);
            parse(p_parser, r, phi, z, varargin{:});
            args = p_parser.Results;
            
            if ~isscalar(z), error('z must be scalar'); end
            
            % --- 1. Calculate Longitudinal Wavenumbers (kz) ---
            % kz = sqrt(k^2 - beta^2)
            kz1 = sqrt(obj.k^2 - obj.beta1^2);
            kz2 = sqrt(obj.k^2 - obj.beta2^2);
            
            % --- 2. Generate Component Bessel Beams (Simplified Gori Model) ---
            % We model them as Bessel-Gaussians so they are physically realizable.
            % Beam 1
            z_R = (pi * obj.w0^2) / obj.wavelength; % Gaussian Rayleigh range
            xi = 1 + 1i * z / z_R;
            
            % Bessel 1
            gauss_env = (1./xi) .* exp(-r.^2 ./ (obj.w0^2 * xi));
            bessel_1  = besselj(0, obj.beta1 * r ./ xi);
            % Axial phase correction for BG
            phase_1   = exp(1i * (obj.beta1^2 * z) / (2*obj.k) ); % Paraxial approx phase shift
            % Or rigorous plane wave: exp(1i * kz1 * z)
            % Let's use the rigorous kz difference for the "beating" effect
            prop_1    = exp(1i * kz1 * z);
            
            E1 = gauss_env .* bessel_1 .* prop_1;
            
            % Bessel 2
            bessel_2  = besselj(0, obj.beta2 * r ./ xi);
            prop_2    = exp(1i * kz2 * z);
            
            E2 = gauss_env .* bessel_2 .* prop_2;
            
            % --- 3. Superposition ---
            % To create a bottle (dark center at z=0), the beams must be 
            % OUT OF PHASE at z=0.
            % If we just sum E1 + E2, they are constructive at z=0 (Bright Spot).
            % We need E1 - E2 (Destructive interference at origin).
            
            field_unscaled = E1 - E2;
            
            % Power Scaling
            scale = 1.0;
            if args.P_tx_watts > 0, scale = sqrt(args.P_tx_watts); end
            
            field = scale * field_unscaled;
            
            if ~isempty(args.tx_aperture_radius)
                field = field .* (r <= args.tx_aperture_radius);
            end
        end
        
        function intensity = calculate_intensity(obj, r, phi, z, varargin)
            field = obj.generate_beam_field(r, phi, z, varargin{:});
            intensity = abs(field).^2;
        end
    end
end